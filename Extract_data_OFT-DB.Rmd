---
title: "Extract_data_OFT-DB"
author: "Javier Pineda"
date: "21/10/2021"
last modification: "05/11/2021"
output:
  pdf_document: default
  html_document: default
  
Im going to add text just to try
---


# INFORMATION

## This script will extract the information from the OpenFoodTox Database (OFT-DB) from EFSA based on compounds of interest. It is essential to have the OFT-DB file in the same folder as the script.

## A function is included, where the user only have to indicate the compound of interest, and finally a .csv file will be produced with the information of all tables in a single one. In addition, the number of results will be printed. 

## To improve:
1. Solve the problem with Genotox ID. Update 28/10/2021: I think there is a problem also with the TRX_ID, because is the same for all values. In STUDY (Index in the script) there is information about if the substance is mutagenic, is genotoxic and if it is carcinogenic.

## Updates:
1. Function 2.0: Includes information from PubChem (27/10/2021)
2. Function 3.0: The information from PubChem only is added if "YES" is written as second input (05/10/2021)
3. Function 4.0: The columns of each datasheet could be selected previously. It remains to decide wich columns (05/11/2021)

## Problems solved:
1. Now there is no problem regarding using capital letters or lowercase (22/10/2021)
2. The warnings loading "Refer_points" where due to the function read_excel can not guess the type of the colum. It was solved adding "guess_max = the number of rows". (10/11/2021)

# EXTRACTION STEP BY STEP

## Libraries needed: tidyverse, readxl, stringr
## For PubChem extraction: webchem

```{r libraries, include=FALSE}
library(tidyverse) # Functions to extract the data
library(readxl)    # Functions to load the xlsx files
library(stringr)   # Functions to include in search both capital letters and not
library(webchem)   # Functions to extract info from PubChem
```

## Steps

### Step 1: Load OFT-DB tables in R

### Each one of the datahseets of the database is load as an unic object.

```{r Load_tables, echo=TRUE, warning=TRUE}
Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY",guess_max = 11354)
Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
```

### Step 2: Substance to search

#### At this point is when the name of the compound has to be introduced. It works for both capital letters and lowercase.

```{r Search_substance, echo=TRUE}
Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), "cadmium"))
```

### Step 3: Creation of an unique table by combination of ID

```{r Creation_table, echo=TRUE}
Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
```

### Step 3.5: Information from PubChem

```{r}
get_cid("lead")
properties <- pc_prop(5352425)

```


### Step 4: Saving the information

```{r Saving_info, echo=TRUE, warning=FALSE}
write_csv2(Complete_6,"Final_table.csv")
```


# FUNCTION 1.0

### With the function, the main differences are that in the screen there is shown the number of compounds selected and the final table has the name of the compound searched.

```{r Function, warning=TRUE}
Extract_data <- function(x) {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY",guess_max = 11354)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(x)))
  y <- count(Component_filter)
  print(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  
  write_csv2(Complete_6,paste(x,".csv"))
  
  message("Search for ", x, " finished with ", y, " components found.")
  
}
```

```{r Example, echo=TRUE, message=FALSE, warning=FALSE}
Extract_data("cadmium")
```


# DATA FROM PUBCHEM

## Pubchem have different identificators: compound identifier (CID), substance identifier (SID), and bioassay identifier (AID)

## I will use the package "â€˜webchem"

```{r library for Pubchem, include=FALSE}
library(webchem)
```

## To obtain the CID 

```{r Obtain CID}
get_cid("lead")
```

## Obtain the properties from the CID

### The information from the table could be selected with the parameter "properties"

```{r}
properties <- pc_prop(5352425)
```


# FUNCTION 2.0

### This function includes information from PubChem

```{r Function, warning=TRUE}
Extract_data_2<- function(x) {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(x)))
  y <- count(Component_filter)
  print(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  pubmed_cid <- get_cid(str_to_lower(x))
  pubmed_prop <- pc_prop(pubmed_cid[,2])
  pubmed_cid <- as.data.frame(pubmed_cid) # This is necessary due to to add a tibble to the data.frame makes not possible to save as csv.
  
  Complete_7 <- mutate(Complete_6, CID = pubmed_cid[,2]) # Now all rows have the value of the CID
  Complete_7$CID <- as.integer(Complete_7$CID) # This avoids problems joining tables
  Complete_8 <- left_join(Complete_7, pubmed_prop, by = "CID")
  
  #write_csv2(Complete_6,paste(x,".csv"))
  write_csv2(Complete_8,paste(x,".csv"))
  write_csv2(pubmed_prop,"properties.csv")
  
  message("Search for ", x, " finished with ", y, " components found.")
  
}
```

```{r Example, echo=TRUE, message=FALSE, warning=FALSE}
Extract_data("LEAD")
```

# Function 3.0

```{r warning=TRUE}
Extract_data_3 <- function(x,z = "NA") {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(x)))
  y <- count(Component_filter)
  print(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  if(missing(z) | (z != "YES")) {
  write_csv2(Complete_6,paste(x,".csv"))
      message("Search for ", x, " finished with ", y, " components found.")
} else {
  pubmed_cid <- get_cid(str_to_lower(x))
  pubmed_prop <- pc_prop(pubmed_cid[,2])
  pubmed_cid <- as.data.frame(pubmed_cid) # This is necessary due to to add a tibble to the data.frame makes not possible to save as csv.
  
  Complete_7 <- mutate(Complete_6, CID = pubmed_cid[,2]) # Now all rows have the value of the CID
  Complete_7$CID <- as.integer(Complete_7$CID) # This avoids problems joining tables
  Complete_8 <- left_join(Complete_7, pubmed_prop, by = "CID")
  
  write_csv2(Complete_8,paste(x,".csv"))
  
  message("Search for ", x, " finished with ", y, " components found. Information from PubChem has been added")
}
}
```

```{r warning=FALSE}
Extract_data_3("LEAD")
```

# Function 4.0

```{r warning=TRUE}
Extract_data_3 <- function(x,z = "NA") {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  #Index = Index %>% select(SUB_COM_ID)
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  #Component = Component %>% select(SUB_COM_ID)
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  #Opinion = Opinion %>% select(SUB_COM_ID)
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  #Question = Question %>% select(SUB_COM_ID)
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  #Refer_points = Refer_points %>% select(SUB_COM_ID)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  #Refer_values = Refer_values %>% select(SUB_COM_ID)
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  #Genotox = Genotox %>% select(SUB_COM_ID)
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(x)))
  y <- count(Component_filter)
  print(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  if(missing(z) | (z != "YES")) {
  write_csv2(Complete_6,paste(x,".csv"))
      message("Search for ", x, " finished with ", y, " components found.")
} else {
  pubmed_cid <- get_cid(str_to_lower(x))
  pubmed_prop <- pc_prop(pubmed_cid[,2])
  pubmed_cid <- as.data.frame(pubmed_cid) # This is necessary due to to add a tibble to the data.frame makes not possible to save as csv.
  
  Complete_7 <- mutate(Complete_6, CID = pubmed_cid[,2]) # Now all rows have the value of the CID
  Complete_7$CID <- as.integer(Complete_7$CID) # This avoids problems joining tables
  Complete_8 <- left_join(Complete_7, pubmed_prop, by = "CID")
  
  write_csv2(Complete_8,paste(x,".csv"))
  
  message("Search for ", x, " finished with ", y, " components found. Information from PubChem has been added")
}
}
```

```{r warning=FALSE}
Extract_data_3("LEAD")
```