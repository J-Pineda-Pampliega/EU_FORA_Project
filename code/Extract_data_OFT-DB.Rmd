---
title: "Extract_data_OFT-DB"
author: "Javier Pineda"
date: "21/10/2021"
last modification: "13/06/2021"
output:
  pdf_document: default
  html_document: default
---

# INFORMATION

## This script will extract the information from the OpenFoodTox Database (OFT-DB) from EFSA based on compounds of interest. It is essential to have the OFT-DB file in the same folder as the script.

## A function is included, where the user only have to indicate the compound of interest, and finally a .csv file will be produced with the information of all tables in a single one. In addition, the number of results will be printed. 

## To improve:
1. Solve the problem with Genotox ID. Update 28/10/2021: I think there is a problem also with the TRX_ID, because is the same for all values. In STUDY (Index in the script) there is information about if the substance is mutagenic, is genotoxic and if it is carcinogenic.
2. There are now problems with PubChem, now is not working, but looks like a problem of the webchem package.

## Updates:
1. Function 2.0: Includes information from PubChem (27/10/2021)
2. Function 3.0: The information from PubChem only is added if "YES" is written as second input (05/10/2021)
3. Function 4.0: The columns of each datasheet could be selected previously. It remains to decide wich columns (05/11/2021)
4. Function 5.0: It searches for terms in column "SUB_NAME", and if don't found anything, looks in colum "Description". I have tried with "HBCDD". (21/11/2021)
5. Function 6.0: It works for three terms at the same time. (29/11/2021)
6. Function 7.0: It search for terms in colum "SUB_NAME" and "SUBPARAMNAE", and works for three terms at the same time. In addition, the information now is saved as .txt, and the problem with the first colum has been solved (it appears a colum with the name of rows as 1,2,3, etc) (06/12/2021)
7. Function 7.0: Now the maximum number of compound to evaluate is 15 (07/12/2021)
8. Function 7.0: Now if the input have repeated values, the function stops and indicate which value is repeated (08/12/2021)
9. Function 8.0: Now the columns are the same as in the on-line tool, with some added (IUPAC Name, SMILE, INCHI). 14/12/2021.

## Problems solved:
1. Now there is no problem regarding using capital letters or lowercase (22/10/2021)
2. The warnings loading "Refer_points" where due to the function read_excel can not guess the type of the colum. It was solved adding "guess_max = the number of rows". (10/11/2021)

# EXTRACTION STEP BY STEP

## Libraries needed: tidyverse, readxl, stringr
## For PubChem extraction: webchem

```{r libraries, include=FALSE}
library(tidyverse) # Functions to extract the data
library(readxl)    # Functions to load the xlsx files
library(stringr)   # Functions to include in search both capital letters and not
library(webchem)   # Functions to extract info from PubChem
```

## Steps

### Step 1: Load OFT-DB tables in R

### Each one of the datahseets of the database is load as an unic object.

# If the chuck for loading tables indicates "Error: path does not exist", then copy and run in the console
```{r Load_tables, echo=TRUE, warning=TRUE}
Index <- read_excel("./data/OpenFoodToxTx22761_2021.xlsx", sheet = "STUDY")
Component <- read_excel("./data/OpenFoodToxTx22761_2021.xlsx", sheet = "COMPONENT")
Opinion <- read_excel("./data/OpenFoodToxTx22761_2021.xlsx", sheet = "OPINION")
Question <- read_excel("./data/OpenFoodToxTx22761_2021.xlsx", sheet = "QUESTION")
Refer_points <- read_excel("./data/OpenFoodToxTx22761_2021.xlsx", sheet = "ENDPOINTSTUDY",guess_max = 11354)
Refer_values <- read_excel("./data/OpenFoodToxTx22761_2021.xlsx", sheet = "CHEM_ASSESS")
Genotox <- read_excel("./data/OpenFoodToxTx22761_2021.xlsx", sheet = "GENOTOX")
```

### Step 2: Substance to search

#### At this point is when the name of the compound has to be introduced. It works for both capital letters and lowercase.

```{r Search_substance, echo=TRUE}
Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), "cadmium"))
```

### Step 3: Creation of an unique table by combination of ID

```{r Creation_table, echo=TRUE}
Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
```

### Step 3.5: Information from PubChem

```{r}
get_cid("cadmium")
properties <- pc_prop(5352425)

```


### Step 4: Saving the information

```{r Saving_info, echo=TRUE, warning=FALSE}
write_csv2(Complete_6,"Final_table.csv")
```


# FUNCTION 1.0

### With the function, the main differences are that in the screen there is shown the number of compounds selected and the final table has the name of the compound searched.

### Inputs are a,b,c... and internal parameters are z,y,x, etc.

```{r Function, warning=TRUE}
Extract_data_1 <- function(a) {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY",guess_max = 11354)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(a)))
  z <- count(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  
  write_csv2(Complete_6,paste(a,".csv"))
  
  message("Search for ", a, " finished with ", z, " components found.")
  
}
```

```{r Example, echo=TRUE, message=FALSE, warning=FALSE}
Extract_data_1("cadmium")
```


# DATA FROM PUBCHEM

## Pubchem have different identificators: compound identifier (CID), substance identifier (SID), and bioassay identifier (AID)

## I will use the package "â€˜webchem"

```{r library for Pubchem, include=FALSE}
library(webchem)
```

## To obtain the CID 

```{r Obtain CID}
get_cid("lead")
```

## Obtain the properties from the CID

### The information from the table could be selected with the parameter "properties"

```{r}
properties <- pc_prop(5352425)
```


# FUNCTION 2.0

### Includes information from PubChem (27/10/2021)

```{r Function, warning=TRUE}
Extract_data_2<- function(a) {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(a)))
  z <- count(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  pubmed_cid <- get_cid(str_to_lower(a))
  pubmed_prop <- pc_prop(pubmed_cid[,2])
  pubmed_cid <- as.data.frame(pubmed_cid) # This is necessary due to to add a tibble to the data.frame makes not possible to save as csv.
  
  Complete_7 <- mutate(Complete_6, CID = pubmed_cid[,2]) # Now all rows have the value of the CID
  Complete_7$CID <- as.integer(Complete_7$CID) # This avoids problems joining tables
  Complete_8 <- left_join(Complete_7, pubmed_prop, by = "CID")
  
  #write_csv2(Complete_6,paste(x,".csv"))
  write_csv2(Complete_8,paste(a,".csv"))
  write_csv2(pubmed_prop,"properties.csv")
  
  message("Search for ", a, " finished with ", z, " components found.")
  
}
```

```{r Example, echo=TRUE, message=FALSE, warning=FALSE}
Extract_data_2("LEAD")
```

# Function 3.0

### The information from PubChem only is added if "YES" is written as second input (05/10/2021)

```{r warning=TRUE}
Extract_data_3 <- function(a,b = "NA") {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(a)))
  z <- count(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  if(missing(b) | (b != "YES")) {
  write_csv2(Complete_6,paste(a,".csv"))
      message("Search for ", a, " finished with ", z, " components found.")
} else {
  pubmed_cid <- get_cid(str_to_lower(a))
  pubmed_prop <- pc_prop(pubmed_cid[,2])
  pubmed_cid <- as.data.frame(pubmed_cid) # This is necessary due to to add a tibble to the data.frame makes not possible to save as csv.
  
  Complete_7 <- mutate(Complete_6, CID = pubmed_cid[,2]) # Now all rows have the value of the CID
  Complete_7$CID <- as.integer(Complete_7$CID) # This avoids problems joining tables
  Complete_8 <- left_join(Complete_7, pubmed_prop, by = "CID")
  
  write_csv2(Complete_8,paste(a,".csv"))
  
  message("Search for ", a, " finished with ", z, " components found. Information from PubChem has been added")
}
}
```

```{r warning=FALSE}
Extract_data_3("LEAD")
```

# Function 4.0

### The columns of each datasheet could be selected previously. It remains to decide wich columns

```{r warning=TRUE}
Extract_data_4 <- function(a,b = "NA") {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  #Index = Index %>% select(SUB_COM_ID)
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  #Component = Component %>% select(SUB_COM_ID)
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  #Opinion = Opinion %>% select(SUB_COM_ID)
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  #Question = Question %>% select(SUB_COM_ID)
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  #Refer_points = Refer_points %>% select(SUB_COM_ID)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  #Refer_values = Refer_values %>% select(SUB_COM_ID)
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  #Genotox = Genotox %>% select(SUB_COM_ID)
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(a)))
  z <- count(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  if(missing(b) | (b != "YES")) {
  write_csv2(Complete_6,paste(a,".csv"))
      message("Search for ", a, " finished with ", z, " components found.")
} else {
  pubmed_cid <- get_cid(str_to_lower(a))
  pubmed_prop <- pc_prop(pubmed_cid[,2])
  pubmed_cid <- as.data.frame(pubmed_cid) # This is necessary due to to add a tibble to the data.frame makes not possible to save as csv.
  
  Complete_7 <- mutate(Complete_6, CID = pubmed_cid[,2]) # Now all rows have the value of the CID
  Complete_7$CID <- as.integer(Complete_7$CID) # This avoids problems joining tables
  Complete_8 <- left_join(Complete_7, pubmed_prop, by = "CID")
  
  write_csv2(Complete_8,paste(a,".csv"))
  
  message("Search for ", a, " finished with ", z, " components found. Information from PubChem has been added")
}
}
```

```{r warning=FALSE}
Extract_data_4("LEAD")
```

# Function 5.0

### It searches for terms in column "SUB_NAME", and if don't found anything, looks in colum "Description". I have tried with "HBCDD".

```{r warning=TRUE}
Extract_data_5 <- function(a,b = "NA") {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  #Index = Index %>% select(SUB_COM_ID)
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  #Component = Component %>% select(SUB_COM_ID)
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  #Opinion = Opinion %>% select(SUB_COM_ID)
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  #Question = Question %>% select(SUB_COM_ID)
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  #Refer_points = Refer_points %>% select(SUB_COM_ID)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  #Refer_values = Refer_values %>% select(SUB_COM_ID)
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  #Genotox = Genotox %>% select(SUB_COM_ID)
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(a)))
  
  z <- count(Component_filter)
  
  if(z == "0"){
    Component_filter <- Component %>% filter(str_detect(str_to_lower(Description), str_to_lower(a)))
  }
  
  z <- count(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  if(missing(b) | (b != "YES")) {
  write_csv2(Complete_6,paste(a,".csv"))
      message("Search for ", a, " finished with ", z, " components found.")
} else {
  pubmed_cid <- get_cid(str_to_lower(a))
  pubmed_prop <- pc_prop(pubmed_cid[,2])
  pubmed_cid <- as.data.frame(pubmed_cid) # This is necessary due to to add a tibble to the data.frame makes not possible to save as csv.
  
  Complete_7 <- mutate(Complete_6, CID = pubmed_cid[,2]) # Now all rows have the value of the CID
  Complete_7$CID <- as.integer(Complete_7$CID) # This avoids problems joining tables
  Complete_8 <- left_join(Complete_7, pubmed_prop, by = "CID")
  
  write_csv2(Complete_8,paste(a,".csv"))
  
  message("Search for ", a, " finished with ", z, " components found. Information from PubChem has been added")
}
}
```

```{r}
Extract_data_5("hbcdd")
```


# Function 6.0

### This function search for 3 terms at the same time.

### Ahora busca 3 compuestos si aparecen en la primera columna, sino, si buscas "hbcdd","lead" solo encuentra el primero.

```{r warning=TRUE}
Extract_data_6 <- function(a,b = "",c = "",PubChem = "NA") {
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  #Index = Index %>% select(SUB_COM_ID)
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  #Component = Component %>% select(SUB_COM_ID)
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  #Opinion = Opinion %>% select(SUB_COM_ID)
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  #Question = Question %>% select(SUB_COM_ID)
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  #Refer_points = Refer_points %>% select(SUB_COM_ID)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  #Refer_values = Refer_values %>% select(SUB_COM_ID)
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  #Genotox = Genotox %>% select(SUB_COM_ID)
  
  if(missing(b)|b == "" & missing(c)|c == ""){
    input = a
  } else if (missing(c)|c == ""){
    input = paste(a,"|",b,"|",sep = "")
  } else {
    input = paste(a,"|",b,"|",c,sep = "")
  }
  
  Component_filter <- Component %>% filter(str_detect(str_to_lower(SUB_NAME), str_to_lower(input)))
  
  z <- count(Component_filter)
  
  if(z == "0"){
    Component_filter <- Component %>% filter(str_detect(str_to_lower(Description), str_to_lower(input)))
  }
  
  z <- count(Component_filter)
  
  Complete_1 <- left_join(Component_filter, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  if(missing(PubChem) | (PubChem != "YES")) {
  write_csv2(Complete_6,paste(a,"&",b,"&",c,".csv"))
      message("Search for ", a," ,",b," ,",c, " finished with ", z, " components found.")
} else {
  pubmed_cid <- get_cid(str_to_lower(x))
  pubmed_prop <- pc_prop(pubmed_cid[,2])
  pubmed_cid <- as.data.frame(pubmed_cid) # This is necessary due to to add a tibble to the data.frame makes not possible to save as csv.
  
  Complete_7 <- mutate(Complete_6, CID = pubmed_cid[,2]) # Now all rows have the value of the CID
  Complete_7$CID <- as.integer(Complete_7$CID) # This avoids problems joining tables
  Complete_8 <- left_join(Complete_7, pubmed_prop, by = "CID")
  
  write_csv2(Complete_8,paste(a,"&",b,"&",c,".csv"))
  
  message("Search for ", a,b,c, " finished with ", z, " components found. Information from PubChem has been added")
}
}
```

```{r}
Extract_data_6("hbcdd")
```


```{r warning=TRUE}
Extract_data_7 <- function(a,b = "Emptyb",c = "Emptyc",d = "Emptyd", e = "Emptye",f = "Emptyf",g = "Emptyg",h = "Emptyh",i = "Emptyi",j = "Emptyj",k = "Emptyk",l = "Emptyl", m = "Emptym",n = "Emptyn",o = "Emptyo",PubChem = "NA") {
  
  # Inputs different from a are "Empty" due to must have a value, and with Empty dont appear nothing searching in the table. Is Emptyb, Emptyc etc to avoid problems with the part to check if some values are repeated.
  
    
  library(tidyverse) # Functions to extract the data
  library(readxl)    # Functions to load the xlsx files
  library(stringr)   # Functions to include in search both capital letters and not
  library(webchem)   # Functions to extract info from PubChem
  
  total_input = c(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
  total_input_dataframe = data.frame(total_input)
  total_input_filtered = total_input_dataframe %>% distinct()
  duplicated = total_input[duplicated(total_input)]
  if (nrow(total_input_dataframe) == nrow(total_input_filtered)){
    message("Non repeated values")
  } else {
    message("The value ", duplicated, " is repeated. Please, check it")
    stop()
  }
  
  message("Please, modify the name of the xlsx file to 'OpenFoodTox.xlsx'")
  
  #setwd(choose.dir(caption = "Please indicate the folder with the Open food file is"))
  
  Index <- read_excel("OpenFoodTox.xlsx", sheet = "STUDY")
  Component <- read_excel("OpenFoodTox.xlsx", sheet = "COMPONENT")
  Opinion <- read_excel("OpenFoodTox.xlsx", sheet = "OPINION")
  Question <- read_excel("OpenFoodTox.xlsx", sheet = "QUESTION")
  Refer_points <- read_excel("OpenFoodTox.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  Refer_values <- read_excel("OpenFoodTox.xlsx", sheet = "CHEM_ASSESS")
  Genotox <- read_excel("OpenFoodTox.xlsx", sheet = "GENOTOX")
  
filter_a = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(a)) | str_detect(str_to_lower(Description), str_to_lower(a)))
filter_b = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(b)) | str_detect(str_to_lower(Description), str_to_lower(b)))
filter_c = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(c)) | str_detect(str_to_lower(Description), str_to_lower(c)))
filter_d = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(d)) | str_detect(str_to_lower(Description), str_to_lower(d)))
filter_e = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(e)) | str_detect(str_to_lower(Description), str_to_lower(e)))
filter_f = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(f)) | str_detect(str_to_lower(Description), str_to_lower(f)))
filter_g = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(g)) | str_detect(str_to_lower(Description), str_to_lower(g)))
filter_h = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(h)) | str_detect(str_to_lower(Description), str_to_lower(h)))
filter_i = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(i)) | str_detect(str_to_lower(Description), str_to_lower(i)))
filter_j = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(j)) | str_detect(str_to_lower(Description), str_to_lower(j)))
filter_k = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(k)) | str_detect(str_to_lower(Description), str_to_lower(k)))
filter_l = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(l)) | str_detect(str_to_lower(Description), str_to_lower(l)))
filter_m = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(m)) | str_detect(str_to_lower(Description), str_to_lower(m)))
filter_n = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(n)) | str_detect(str_to_lower(Description), str_to_lower(n)))
filter_o = filter(Component, str_detect(str_to_lower(SUB_NAME), str_to_lower(o)) | str_detect(str_to_lower(Description), str_to_lower(o)))

aa <- count(filter_a)
bb <- count(filter_b)
cc <- count(filter_c)
dd <- count(filter_d)
ee <- count(filter_e)
ff <- count(filter_f)
gg <- count(filter_g)
hh <- count(filter_h)
ii <- count(filter_i)
jj <- count(filter_j)
kk <- count(filter_k)
ll <- count(filter_l)
mm <- count(filter_m)
nn <- count(filter_n)
oo <- count(filter_o)

filter_abc = rbind(filter_a, filter_b, filter_c, filter_d, filter_e, filter_f, filter_g, filter_h, filter_i, filter_j, filter_k, filter_l, filter_m, filter_n, filter_o)
  
  Complete_1 <- left_join(filter_abc, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "OP_ID")
  Complete_3 <- left_join(Complete_2, Question, by = "OP_ID")
  Complete_4 <- left_join(Complete_3, Refer_points, by = "TOX_ID")
  Complete_5 <- left_join(Complete_4, Refer_values, by = "HAZARD_ID")
  Complete_6 <- left_join(Complete_5, Genotox, by = "GENOTOX_ID")
  
  Complete_7 <-select(Complete_6, -c(CHEMASSESS_ID, HAZARD_ID, TRX_ID, ASSESSMENTTYPE_ID, RISKQUALIFIER_ID, RISKUNIT_ID, COM_GROUP_ID, TRX_ID.x, TRX_ID.y, TRX_ID.x.x, TRX_ID.y.y, TRX_ID.x.x.x, TRX_ID.y.y.y, GENOTOX_ID, QUESTION_ID, GENOTOXICITY_ID, GENOTOXGUIDELINE_ID, SPECIES_CODE_ID, STRAIN_ID.x, STRAIN_ID.y, ROUTE_ID.x, ROUTE_ID.y, EXPPERIODUNIT_ID, ENDPOINTSTUDY_ID, TOX_ID, TESTTYPE_ID, GUIDELINE_ID, SPECIES_ID, DURATIONUNIT_ID, ENDPOINT_ID, QUALIFIER_ID.x, QUALIFIER_ID.y, DOSEUNIT_ID, BASIS_ID, TOXICITY_ID, TARGETTISSUE_ID, COMGROUP_ID, SUBSTANCECOMPONENT_ID, SUB_COM_ID, SUB_ID, COM_ID, SUBPARAM_ID, COMPARAM_ID, FACTSTUDY_ID, STUDY_ID, SUB_COM_ID, TOX_ID, TOXREF_ID, DOCTYPE_ID, REGULATION_ID, OP_ID, DOCUMENT_ID, CONTROL.y, DEVIATION.y, GLP_COMPL.y, GUIDELINE_QUALIFIER.y, IS_GENOTOXIC.y, NUMBER_INDIVIDUALS.y, QUALIFIER.y, QUALIFIER_CODE.y, ROUTE.y, ROUTE_CODE.y, SEX.y, SPECIES.y, SPECIES_CODE.y, STRAIN.y, STRAIN_CODE.y, STUDY_CATEGORY.y, REMARKS.x, REMARKS.y, GROUP_REMARKS.y, GROUP_UNIT.y)
)
  
      if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyg" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l != "Emptyl" & m != "Emptym" & n != "Emptyn" & o != "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k," & ",l," & ",m," & ",n," & ",o,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished:", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k, "\n", ll, " entries for ", l, "\n", mm, " entries for ", m, "\n", nn, " entries for ", n, "\n", oo, " entries for ", o)
    }
   
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l != "Emptyl" & m != "Emptym" & n != "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k," & ",l," & ",m," & ",n,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished:", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k, "\n", ll, " entries for ", l, "\n", mm, " entries for ", m, "\n", nn, " entries for ", n)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l != "Emptyl" & m != "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k," & ",l," & ",m,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k, "\n", ll, " entries for ", l, "\n", mm, " entries for ", m)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l != "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k," & ",l,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k, "\n", ll, " entries for ", l)
    }
   
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a, " & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i, ".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ", h,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g)
    }
    
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, "entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f)
    } 
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b, " & ",c, " & ",d," & ",e, ".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e)
    } 
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e == "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b, " & ",c, " & ",d,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d)
    } 
  
    if(b != "Emptyb" & c != "Emptyc" & d == "Emptyd" & e == "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a," & ",b, " & ",c,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ","\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c)
    } 
  
    if(b!= "Emptyb" & c == "Emptyc" & d == "Emptyd" & e == "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a, " & ",b, ".txt"), sep = "\t", row.names = FALSE)
    message("Search finished:", "\n", aa, " entries for ", a, "\n" , bb, " entries for ", b)
    } 
  
    if(b == "Emptyb" & c == "Emptyc" & d == "Emptyd" & e == "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_7,paste(a,".txt"), sep = "\t", row.names = FALSE)
      write.csv2(Complete_7,paste(a,".csv"), row.names = FALSE)
      write.csv2(Complete_6,paste(a,"complete.csv"), row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a)
    } 
}
```

```{r}
Extract_data_7("lead")

# He quitado que tengas que elegir carpeta, y ademÃ¡s crea un .csv
# Creo un csv con todas las columnas
```


```{r warning=TRUE}
Extract_data_8 <- function(a,b = "Emptyb",c = "Emptyc",d = "Emptyd", e = "Emptye",f = "Emptyf",g = "Emptyg",h = "Emptyh",i = "Emptyi",j = "Emptyj",k = "Emptyk",l = "Emptyl", m = "Emptym",n = "Emptyn",o = "Emptyo",PubChem = "NA") {
  
  # Inputs different of "a" are "Empty" due to must have a value, and with Empty don't appear nothing searching in the table. Is Emptyb, Emptyc etc to avoid problems with the part to check if some values are repeated.
  
  
  # Chunk 1: Libraries  
  library(tidyverse) # Functions to extract the data
  library(readxl)    # Functions to load the xlsx files
  library(stringr)   # Functions to include in search both capital letters and not
  library(webchem)   # Functions to extract info from PubChem
  
  # Chunk 2: Checking repeated values in input
  total_input = c(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) # Creation of a vector with the inputs
  total_input_dataframe = data.frame(total_input) # Conversion into data.frame
  total_input_filtered = total_input_dataframe %>% distinct() # Only unique values
  
  # Next conditional check if the lenght of the total input is the same of the one without duplicates
  if (nrow(total_input_dataframe) == nrow(total_input_filtered)){ 
    message("Non repeated values")
  } else {
    message("The value ", duplicated, " is repeated. Please, check it")
    stop()
  }
  
  # Chunk 3: Load OpenFood
  
  #message("Please, modify the name of the xlsx file to 'OpenFoodTox.xlsx'")
  
  setwd(choose.dir(caption = "Please indicate the folder with the Open food file is"))
  
  Index <- read_excel("OpenFoodToxTx22761_2021.xlsx", sheet = "STUDY") # Load the datasheet
  Index = Index %>% select("SUB_COM_ID","OP_ID","TOX_ID","GENOTOX_ID","HAZARD_ID") # Select columns
  names(Index) = c("SUB_COM_ID","Output Id","TOX_ID","GENOTOX_ID","HAZARD_ID") # Change name of columns
  
  Component <- read_excel("OpenFoodToxTx22761_2021.xlsx", sheet = "COMPONENT")
  Component <- Component %>% select(SUB_COM_ID,SUB_NAME,SUBPARAMNAME,QUALIFIER,COM_NAME,SUB_CASNUMBER,SUB_ECSUBINVENTENTRYREF,MOLECULARFORMULA,SMILESNOTATION,INCHI,IUPACNAME)
  names(Component) = c("SUB_COM_ID","Substance","Description","has","Component","CAS number", "EC Ref No", "Molecular formula", "Smiles", "INCHI", "IUPAC Name")
  
  Opinion <- read_excel("OpenFoodToxTx22761_2021.xlsx", sheet = "OPINION")
  Opinion <- Opinion %>% select(AUTHOR,PUBLICATIONDATE,OP_ID,TITLE,DOCTYPE,REGULATION,URL)
  names(Opinion) = c("Author","Published","Output Id","Title", "Output Type", "Legal Basis", "URL")
  
  Refer_points <- read_excel("OpenFoodToxTx22761_2021.xlsx", sheet = "ENDPOINTSTUDY", guess_max = 11354)
  Refer_points <- Refer_points %>% select(TOX_ID,STUDY_CATEGORY,TESTTYPE,SPECIES,ROUTE,EXP_DURATION_DAYS,ENDPOINT,QUALIFIER,VALUE,DOSEUNIT,BASIS,TOXICITY)
  names(Refer_points) = c("TOX_ID","Study","Test Type", "Species", "Route", "Duration (Days)", "Endpoint","Qualifier","Value Reference Point","Unit Reference Point","Effect","Toxicity")
  
  Refer_values <- read_excel("OpenFoodToxTx22761_2021.xlsx", sheet = "CHEM_ASSESS")
  Refer_values <- Refer_values %>% select(HAZARD_ID,ASSESSMENTTYPE,RISKVALUE,RISKUNIT,POPULATIONTEXT,REMARKS)
  names(Refer_values) = c("HAZARD_ID","Assessment","Value Reference Value","Unit Reference Value","Population","Remarks")

  Genotox <- read_excel("OpenFoodToxTx22761_2021.xlsx", sheet = "GENOTOX")
  Genotox <- Genotox %>% select(GENOTOX_ID,IS_GENOTOXIC)
  names(Genotox) = c("GENOTOX_ID","Genotoxicity")
  
  
  # Chunk 4: Filtering 
  # The input is filtered in two columns, regarding SUB_NAME (Substance name as defined in the opinions. If multiple names for the same substances are reported, the most specific (or more common) is reported. No synonyms are foreseen for substance name) and SUBPARAMNAME (Description from  EFSA PARAM catalogue)
  
filter_a = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(a)) | str_detect(str_to_lower(Description), str_to_lower(a)))
filter_b = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(b)) | str_detect(str_to_lower(Description), str_to_lower(b)))
filter_c = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(c)) | str_detect(str_to_lower(Description), str_to_lower(c)))
filter_d = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(d)) | str_detect(str_to_lower(Description), str_to_lower(d)))
filter_e = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(e)) | str_detect(str_to_lower(Description), str_to_lower(e)))
filter_f = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(f)) | str_detect(str_to_lower(Description), str_to_lower(f)))
filter_g = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(g)) | str_detect(str_to_lower(Description), str_to_lower(g)))
filter_h = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(h)) | str_detect(str_to_lower(Description), str_to_lower(h)))
filter_i = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(i)) | str_detect(str_to_lower(Description), str_to_lower(i)))
filter_j = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(j)) | str_detect(str_to_lower(Description), str_to_lower(j)))
filter_k = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(k)) | str_detect(str_to_lower(Description), str_to_lower(k)))
filter_l = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(l)) | str_detect(str_to_lower(Description), str_to_lower(l)))
filter_m = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(m)) | str_detect(str_to_lower(Description), str_to_lower(m)))
filter_n = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(n)) | str_detect(str_to_lower(Description), str_to_lower(n)))
filter_o = filter(Component, str_detect(str_to_lower(Substance), str_to_lower(o)) | str_detect(str_to_lower(Description), str_to_lower(o)))

# This part is to count the results of each term in the input

aa <- count(filter_a)
bb <- count(filter_b)
cc <- count(filter_c)
dd <- count(filter_d)
ee <- count(filter_e)
ff <- count(filter_f)
gg <- count(filter_g)
hh <- count(filter_h)
ii <- count(filter_i)
jj <- count(filter_j)
kk <- count(filter_k)
ll <- count(filter_l)
mm <- count(filter_m)
nn <- count(filter_n)
oo <- count(filter_o)

# Chunk 5: Merging

# All the Component table filtered by each term of the input are merging together.

filter_abc = rbind(filter_a, filter_b, filter_c, filter_d, filter_e, filter_f, filter_g, filter_h, filter_i, filter_j, filter_k, filter_l, filter_m, filter_n, filter_o)
  
# The different sheets are joined

  Complete_1 <- left_join(filter_abc, Index, by = "SUB_COM_ID")
  Complete_2 <- left_join(Complete_1, Opinion, by = "Output Id")
  #Complete_3 <- left_join(Complete_2, Question, by = "Output Id")
  Complete_3 <- left_join(Complete_2, Refer_points, by = "TOX_ID")
  Complete_4 <- left_join(Complete_3, Refer_values, by = "HAZARD_ID")
  Complete_5 <- left_join(Complete_4, Genotox, by = "GENOTOX_ID")
  Complete_6 <- select(Complete_5, -c(SUB_COM_ID,TOX_ID,GENOTOX_ID,HAZARD_ID)) # Here we eliminate internal identificators, which in addition allows to eliminate some rows.
  Complete_7 <- distinct(Complete_6) # To eliminate duplicate rows.
  Complete_8 <- Complete_7 %>% relocate(Substance,Description,Component, `CAS number`,`EC Ref No`,`Molecular formula`,Smiles,INCHI,`IUPAC Name`,has) # To relocate the columns to start with the names and identificator of the compounds.
  
  # Chunk 6: Results
  
  # Each block is to show different results in the console and save file with different name depending of the number of names in the input.
  
      if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyg" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l != "Emptyl" & m != "Emptym" & n != "Emptyn" & o != "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k," & ",l," & ",m," & ",n," & ",o,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished:", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k, "\n", ll, " entries for ", l, "\n", mm, " entries for ", m, "\n", nn, " entries for ", n, "\n", oo, " entries for ", o)
    }
   
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l != "Emptyl" & m != "Emptym" & n != "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k," & ",l," & ",m," & ",n,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished:", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k, "\n", ll, " entries for ", l, "\n", mm, " entries for ", m, "\n", nn, " entries for ", n)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l != "Emptyl" & m != "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k," & ",l," & ",m,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k, "\n", ll, " entries for ", l, "\n", mm, " entries for ", m)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l != "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k," & ",l,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k, "\n", ll, " entries for ", l)
    }
   
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k != "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j," & ",k,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j, "\n", kk, " entries for ", k)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j != "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a, " & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i," & ",j,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i, "\n", jj, " entries for ", j)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i != "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ",h," & ",i, ".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h, "\n", ii, " entries for ", i)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h != "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g," & ", h,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g, "\n", hh, " entries for ", h)
    }
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g != "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f," & ",g,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f, "\n", gg, " entries for ", g)
    }
    
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f != "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b," & ",c," & ",d," & ",e," & ",f,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, "entries for ", d, "\n", ee, " entries for ", e, "\n", ff, " entries for ", f)
    } 
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e != "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b, " & ",c, " & ",d," & ",e, ".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d, "\n", ee, " entries for ", e)
    } 
  
    if(b != "Emptyb" & c != "Emptyc" & d != "Emptyd" & e == "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b, " & ",c, " & ",d,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c, "\n", dd, " entries for ", d)
    } 
  
    if(b != "Emptyb" & c != "Emptyc" & d == "Emptyd" & e == "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a," & ",b, " & ",c,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ","\n", aa, " entries for ", a, "\n", bb, " entries for ", b, "\n", cc, " entries for ", c)
    } 
  
    if(b!= "Emptyb" & c == "Emptyc" & d == "Emptyd" & e == "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a, " & ",b, ".txt"), sep = "\t", row.names = FALSE)
    message("Search finished:", "\n", aa, " entries for ", a, "\n" , bb, " entries for ", b)
    } 
  
    if(b == "Emptyb" & c == "Emptyc" & d == "Emptyd" & e == "Emptye" & f == "Emptyf" & g == "Emptyg" & h == "Emptyh" & i == "Emptyi" & j == "Emptyj" & k == "Emptyk" & l == "Emptyl" & m == "Emptym" & n == "Emptyn" & o == "Emptyo") {
  write.table(Complete_8,paste(a,".txt"), sep = "\t", row.names = FALSE)
    message("Search finished: ", "\n", aa, " entries for ", a)
    } 
}
```

```{r}
Extract_data_8("lead")
``